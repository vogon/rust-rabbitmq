/* automatically generated by rust-bindgen */

pub type __builtin_va_list = *mut ::libc::c_char;
pub type __u_char = ::libc::c_uchar;
pub type __u_short = ::libc::c_ushort;
pub type __u_int = ::libc::c_uint;
pub type __u_long = ::libc::c_ulong;
pub type __int8_t = ::libc::c_char;
pub type __uint8_t = ::libc::c_uchar;
pub type __int16_t = ::libc::c_short;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_longlong;
pub type __uint64_t = ::libc::c_ulonglong;
pub type __quad_t = ::libc::c_longlong;
pub type __u_quad_t = ::libc::c_ulonglong;
pub type __dev_t = __u_quad_t;
pub type __uid_t = ::libc::c_uint;
pub type __gid_t = ::libc::c_uint;
pub type __ino_t = ::libc::c_ulong;
pub type __ino64_t = __u_quad_t;
pub type __mode_t = ::libc::c_uint;
pub type __nlink_t = ::libc::c_uint;
pub type __off_t = ::libc::c_long;
pub type __off64_t = __quad_t;
pub type __pid_t = ::libc::c_int;
#[repr(C)]
pub struct __fsid_t {
    pub __val: [::libc::c_int, ..2u],
}
pub type __clock_t = ::libc::c_long;
pub type __rlim_t = ::libc::c_ulong;
pub type __rlim64_t = __u_quad_t;
pub type __id_t = ::libc::c_uint;
pub type __time_t = ::libc::c_long;
pub type __useconds_t = ::libc::c_uint;
pub type __suseconds_t = ::libc::c_long;
pub type __daddr_t = ::libc::c_int;
pub type __key_t = ::libc::c_int;
pub type __clockid_t = ::libc::c_int;
pub type __timer_t = *mut ::libc::c_void;
pub type __blksize_t = ::libc::c_long;
pub type __blkcnt_t = ::libc::c_long;
pub type __blkcnt64_t = __quad_t;
pub type __fsblkcnt_t = ::libc::c_ulong;
pub type __fsblkcnt64_t = __u_quad_t;
pub type __fsfilcnt_t = ::libc::c_ulong;
pub type __fsfilcnt64_t = __u_quad_t;
pub type __fsword_t = ::libc::c_int;
pub type __ssize_t = ::libc::c_int;
pub type __syscall_slong_t = ::libc::c_long;
pub type __syscall_ulong_t = ::libc::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::libc::c_char;
pub type __intptr_t = ::libc::c_int;
pub type __socklen_t = ::libc::c_uint;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ptrdiff_t = ::libc::c_int;
pub type size_t = ::libc::c_uint;
pub type wchar_t = ::libc::c_int;
pub type ulong = ::libc::c_ulong;
pub type ushort = ::libc::c_ushort;
pub type _uint = ::libc::c_uint;
pub type int8_t = ::libc::c_char;
pub type int16_t = ::libc::c_short;
pub type int32_t = ::libc::c_int;
pub type int64_t = ::libc::c_longlong;
pub type u_int8_t = ::libc::c_uchar;
pub type u_int16_t = ::libc::c_ushort;
pub type u_int32_t = ::libc::c_uint;
pub type u_int64_t = ::libc::c_ulonglong;
pub type register_t = ::libc::c_int;
pub type __sig_atomic_t = ::libc::c_int;
#[repr(C)]
pub struct __sigset_t {
    pub __val: [::libc::c_ulong, ..32u],
}
pub type sigset_t = __sigset_t;
#[repr(C)]
pub struct Struct_timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[repr(C)]
pub struct Struct_timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::libc::c_long;
#[repr(C)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask, ..32u],
}
pub type fd_mask = __fd_mask;
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::libc::c_ulong;
#[repr(C)]
pub struct Union_pthread_attr_t {
    pub data: [u32, ..9u],
}
impl Union_pthread_attr_t {
    pub fn __size(&mut self) -> *mut [::libc::c_char, ..36u] {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn __align(&mut self) -> *mut ::libc::c_long {
        unsafe { ::std::mem::transmute(self) }
    }
}
pub type pthread_attr_t = Union_pthread_attr_t;
#[repr(C)]
pub struct Struct___pthread_internal_slist {
    pub __next: *mut Struct___pthread_internal_slist,
}
pub type __pthread_slist_t = Struct___pthread_internal_slist;
#[repr(C)]
pub struct Struct___pthread_mutex_s {
    pub __lock: ::libc::c_int,
    pub __count: ::libc::c_uint,
    pub __owner: ::libc::c_int,
    pub __kind: ::libc::c_int,
    pub __nusers: ::libc::c_uint,
}
#[repr(C)]
pub struct Union_Unnamed1 {
    pub data: [u32, ..1u],
}
impl Union_Unnamed1 {
    pub fn d(&mut self) -> *mut Struct_Unnamed2 {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn __list(&mut self) -> *mut __pthread_slist_t {
        unsafe { ::std::mem::transmute(self) }
    }
}
#[repr(C)]
pub struct Struct_Unnamed2 {
    pub __espins: ::libc::c_short,
    pub __elision: ::libc::c_short,
}
#[repr(C)]
pub struct pthread_mutex_t {
    pub data: [u32, ..6u],
}
impl pthread_mutex_t {
    pub fn __data(&mut self) -> *mut Struct___pthread_mutex_s {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn __size(&mut self) -> *mut [::libc::c_char, ..24u] {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn __align(&mut self) -> *mut ::libc::c_long {
        unsafe { ::std::mem::transmute(self) }
    }
}
#[repr(C)]
pub struct pthread_mutexattr_t {
    pub data: [u32, ..1u],
}
impl pthread_mutexattr_t {
    pub fn __size(&mut self) -> *mut [::libc::c_char, ..4u] {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn __align(&mut self) -> *mut ::libc::c_int {
        unsafe { ::std::mem::transmute(self) }
    }
}
#[repr(C)]
pub struct Struct_Unnamed3 {
    pub __lock: ::libc::c_int,
    pub __futex: ::libc::c_uint,
    pub __total_seq: ::libc::c_ulonglong,
    pub __wakeup_seq: ::libc::c_ulonglong,
    pub __woken_seq: ::libc::c_ulonglong,
    pub __mutex: *mut ::libc::c_void,
    pub __nwaiters: ::libc::c_uint,
    pub __broadcast_seq: ::libc::c_uint,
}
#[repr(C)]
pub struct pthread_cond_t {
    pub data: [u32, ..12u],
}
impl pthread_cond_t {
    pub fn __data(&mut self) -> *mut Struct_Unnamed3 {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn __size(&mut self) -> *mut [::libc::c_char, ..48u] {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn __align(&mut self) -> *mut ::libc::c_longlong {
        unsafe { ::std::mem::transmute(self) }
    }
}
#[repr(C)]
pub struct pthread_condattr_t {
    pub data: [u32, ..1u],
}
impl pthread_condattr_t {
    pub fn __size(&mut self) -> *mut [::libc::c_char, ..4u] {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn __align(&mut self) -> *mut ::libc::c_int {
        unsafe { ::std::mem::transmute(self) }
    }
}
pub type pthread_key_t = ::libc::c_uint;
pub type pthread_once_t = ::libc::c_int;
#[repr(C)]
pub struct Struct_Unnamed4 {
    pub __lock: ::libc::c_int,
    pub __nr_readers: ::libc::c_uint,
    pub __readers_wakeup: ::libc::c_uint,
    pub __writer_wakeup: ::libc::c_uint,
    pub __nr_readers_queued: ::libc::c_uint,
    pub __nr_writers_queued: ::libc::c_uint,
    pub __flags: ::libc::c_uchar,
    pub __shared: ::libc::c_uchar,
    pub __pad1: ::libc::c_uchar,
    pub __pad2: ::libc::c_uchar,
    pub __writer: ::libc::c_int,
}
#[repr(C)]
pub struct pthread_rwlock_t {
    pub data: [u32, ..8u],
}
impl pthread_rwlock_t {
    pub fn __data(&mut self) -> *mut Struct_Unnamed4 {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn __size(&mut self) -> *mut [::libc::c_char, ..32u] {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn __align(&mut self) -> *mut ::libc::c_long {
        unsafe { ::std::mem::transmute(self) }
    }
}
#[repr(C)]
pub struct pthread_rwlockattr_t {
    pub data: [u32, ..2u],
}
impl pthread_rwlockattr_t {
    pub fn __size(&mut self) -> *mut [::libc::c_char, ..8u] {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn __align(&mut self) -> *mut ::libc::c_long {
        unsafe { ::std::mem::transmute(self) }
    }
}
pub type pthread_spinlock_t = ::libc::c_int;
#[repr(C)]
pub struct pthread_barrier_t {
    pub data: [u32, ..5u],
}
impl pthread_barrier_t {
    pub fn __size(&mut self) -> *mut [::libc::c_char, ..20u] {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn __align(&mut self) -> *mut ::libc::c_long {
        unsafe { ::std::mem::transmute(self) }
    }
}
#[repr(C)]
pub struct pthread_barrierattr_t {
    pub data: [u32, ..1u],
}
impl pthread_barrierattr_t {
    pub fn __size(&mut self) -> *mut [::libc::c_char, ..4u] {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn __align(&mut self) -> *mut ::libc::c_int {
        unsafe { ::std::mem::transmute(self) }
    }
}
#[repr(C)]
pub struct Struct_iovec {
    pub iov_base: *mut ::libc::c_void,
    pub iov_len: size_t,
}
pub type uint8_t = ::libc::c_uchar;
pub type uint16_t = ::libc::c_ushort;
pub type uint32_t = ::libc::c_uint;
pub type uint64_t = ::libc::c_ulonglong;
pub type int_least8_t = ::libc::c_char;
pub type int_least16_t = ::libc::c_short;
pub type int_least32_t = ::libc::c_int;
pub type int_least64_t = ::libc::c_longlong;
pub type uint_least8_t = ::libc::c_uchar;
pub type uint_least16_t = ::libc::c_ushort;
pub type uint_least32_t = ::libc::c_uint;
pub type uint_least64_t = ::libc::c_ulonglong;
pub type int_fast8_t = ::libc::c_char;
pub type int_fast16_t = ::libc::c_int;
pub type int_fast32_t = ::libc::c_int;
pub type int_fast64_t = ::libc::c_longlong;
pub type uint_fast8_t = ::libc::c_uchar;
pub type uint_fast16_t = ::libc::c_uint;
pub type uint_fast32_t = ::libc::c_uint;
pub type uint_fast64_t = ::libc::c_ulonglong;
pub type intptr_t = ::libc::c_int;
pub type uintptr_t = ::libc::c_uint;
pub type intmax_t = ::libc::c_longlong;
pub type uintmax_t = ::libc::c_ulonglong;
pub type amqp_boolean_t = ::libc::c_int;
pub type amqp_method_number_t = uint32_t;
pub type amqp_flags_t = uint32_t;
pub type amqp_channel_t = uint16_t;
#[repr(C)]
pub struct Struct_amqp_bytes_t_ {
    pub len: size_t,
    pub bytes: *mut ::libc::c_void,
}
pub type amqp_bytes_t = Struct_amqp_bytes_t_;
#[repr(C)]
pub struct Struct_amqp_decimal_t_ {
    pub decimals: uint8_t,
    pub value: uint32_t,
}
pub type amqp_decimal_t = Struct_amqp_decimal_t_;
#[repr(C)]
pub struct Struct_amqp_table_t_ {
    pub num_entries: ::libc::c_int,
    pub entries: *mut Struct_amqp_table_entry_t_,
}
pub type amqp_table_t = Struct_amqp_table_t_;
#[repr(C)]
pub struct Struct_amqp_array_t_ {
    pub num_entries: ::libc::c_int,
    pub entries: *mut Struct_amqp_field_value_t_,
}
pub type amqp_array_t = Struct_amqp_array_t_;
#[repr(C)]
pub struct Struct_amqp_field_value_t_ {
    pub kind: uint8_t,
    pub value: Union_Unnamed5,
}
#[repr(C)]
pub struct Union_Unnamed5 {
    pub data: [u32, ..2u],
}
impl Union_Unnamed5 {
    pub fn boolean(&mut self) -> *mut amqp_boolean_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn i8(&mut self) -> *mut int8_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn u8(&mut self) -> *mut uint8_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn i16(&mut self) -> *mut int16_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn u16(&mut self) -> *mut uint16_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn i32(&mut self) -> *mut int32_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn u32(&mut self) -> *mut uint32_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn i64(&mut self) -> *mut int64_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn u64(&mut self) -> *mut uint64_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn f32(&mut self) -> *mut ::libc::c_float {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn f64(&mut self) -> *mut ::libc::c_double {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn decimal(&mut self) -> *mut amqp_decimal_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn bytes(&mut self) -> *mut amqp_bytes_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn table(&mut self) -> *mut amqp_table_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn array(&mut self) -> *mut amqp_array_t {
        unsafe { ::std::mem::transmute(self) }
    }
}
pub type amqp_field_value_t = Struct_amqp_field_value_t_;
#[repr(C)]
pub struct Struct_amqp_table_entry_t_ {
    pub key: amqp_bytes_t,
    pub value: amqp_field_value_t,
}
pub type amqp_table_entry_t = Struct_amqp_table_entry_t_;
pub type amqp_field_value_kind_t = ::libc::c_uint;
pub static AMQP_FIELD_KIND_BOOLEAN: ::libc::c_uint = 116;
pub static AMQP_FIELD_KIND_I8: ::libc::c_uint = 98;
pub static AMQP_FIELD_KIND_U8: ::libc::c_uint = 66;
pub static AMQP_FIELD_KIND_I16: ::libc::c_uint = 115;
pub static AMQP_FIELD_KIND_U16: ::libc::c_uint = 117;
pub static AMQP_FIELD_KIND_I32: ::libc::c_uint = 73;
pub static AMQP_FIELD_KIND_U32: ::libc::c_uint = 105;
pub static AMQP_FIELD_KIND_I64: ::libc::c_uint = 108;
pub static AMQP_FIELD_KIND_U64: ::libc::c_uint = 76;
pub static AMQP_FIELD_KIND_F32: ::libc::c_uint = 102;
pub static AMQP_FIELD_KIND_F64: ::libc::c_uint = 100;
pub static AMQP_FIELD_KIND_DECIMAL: ::libc::c_uint = 68;
pub static AMQP_FIELD_KIND_UTF8: ::libc::c_uint = 83;
pub static AMQP_FIELD_KIND_ARRAY: ::libc::c_uint = 65;
pub static AMQP_FIELD_KIND_TIMESTAMP: ::libc::c_uint = 84;
pub static AMQP_FIELD_KIND_TABLE: ::libc::c_uint = 70;
pub static AMQP_FIELD_KIND_VOID: ::libc::c_uint = 86;
pub static AMQP_FIELD_KIND_BYTES: ::libc::c_uint = 120;
#[repr(C)]
pub struct Struct_amqp_pool_blocklist_t_ {
    pub num_blocks: ::libc::c_int,
    pub blocklist: *mut *mut ::libc::c_void,
}
pub type amqp_pool_blocklist_t = Struct_amqp_pool_blocklist_t_;
#[repr(C)]
pub struct Struct_amqp_pool_t_ {
    pub pagesize: size_t,
    pub pages: amqp_pool_blocklist_t,
    pub large_blocks: amqp_pool_blocklist_t,
    pub next_page: ::libc::c_int,
    pub alloc_block: *mut ::libc::c_char,
    pub alloc_used: size_t,
}
pub type amqp_pool_t = Struct_amqp_pool_t_;
#[repr(C)]
pub struct Struct_amqp_method_t_ {
    pub id: amqp_method_number_t,
    pub decoded: *mut ::libc::c_void,
}
pub type amqp_method_t = Struct_amqp_method_t_;
#[repr(C)]
pub struct Struct_amqp_frame_t_ {
    pub frame_type: uint8_t,
    pub channel: amqp_channel_t,
    pub payload: Union_Unnamed6,
}
#[repr(C)]
pub struct Union_Unnamed6 {
    pub data: [u32, ..6u],
}
impl Union_Unnamed6 {
    pub fn method(&mut self) -> *mut amqp_method_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn properties(&mut self) -> *mut Struct_Unnamed7 {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn body_fragment(&mut self) -> *mut amqp_bytes_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn protocol_header(&mut self) -> *mut Struct_Unnamed8 {
        unsafe { ::std::mem::transmute(self) }
    }
}
#[repr(C)]
pub struct Struct_Unnamed7 {
    pub class_id: uint16_t,
    pub body_size: uint64_t,
    pub decoded: *mut ::libc::c_void,
    pub raw: amqp_bytes_t,
}
#[repr(C)]
pub struct Struct_Unnamed8 {
    pub transport_high: uint8_t,
    pub transport_low: uint8_t,
    pub protocol_version_major: uint8_t,
    pub protocol_version_minor: uint8_t,
}
pub type amqp_frame_t = Struct_amqp_frame_t_;
pub type Enum_amqp_response_type_enum_ = ::libc::c_uint;
pub static AMQP_RESPONSE_NONE: ::libc::c_uint = 0;
pub static AMQP_RESPONSE_NORMAL: ::libc::c_uint = 1;
pub static AMQP_RESPONSE_LIBRARY_EXCEPTION: ::libc::c_uint = 2;
pub static AMQP_RESPONSE_SERVER_EXCEPTION: ::libc::c_uint = 3;
pub type amqp_response_type_enum = Enum_amqp_response_type_enum_;
#[repr(C)]
pub struct Struct_amqp_rpc_reply_t_ {
    pub reply_type: amqp_response_type_enum,
    pub reply: amqp_method_t,
    pub library_error: ::libc::c_int,
}
pub type amqp_rpc_reply_t = Struct_amqp_rpc_reply_t_;
pub type Enum_amqp_sasl_method_enum_ = ::libc::c_uint;
pub static AMQP_SASL_METHOD_PLAIN: ::libc::c_uint = 0;
pub type amqp_sasl_method_enum = Enum_amqp_sasl_method_enum_;
pub enum Struct_amqp_connection_state_t_ { }
pub type amqp_connection_state_t = *mut Struct_amqp_connection_state_t_;
pub enum Struct_amqp_socket_t_ { }
pub type amqp_socket_t = Struct_amqp_socket_t_;
pub type Enum_amqp_status_enum_ = ::libc::c_int;
pub static AMQP_STATUS_OK: ::libc::c_int = 0;
pub static AMQP_STATUS_NO_MEMORY: ::libc::c_int = -1;
pub static AMQP_STATUS_BAD_AMQP_DATA: ::libc::c_int = -2;
pub static AMQP_STATUS_UNKNOWN_CLASS: ::libc::c_int = -3;
pub static AMQP_STATUS_UNKNOWN_METHOD: ::libc::c_int = -4;
pub static AMQP_STATUS_HOSTNAME_RESOLUTION_FAILED: ::libc::c_int = -5;
pub static AMQP_STATUS_INCOMPATIBLE_AMQP_VERSION: ::libc::c_int = -6;
pub static AMQP_STATUS_CONNECTION_CLOSED: ::libc::c_int = -7;
pub static AMQP_STATUS_BAD_URL: ::libc::c_int = -8;
pub static AMQP_STATUS_SOCKET_ERROR: ::libc::c_int = -9;
pub static AMQP_STATUS_INVALID_PARAMETER: ::libc::c_int = -10;
pub static AMQP_STATUS_TABLE_TOO_BIG: ::libc::c_int = -11;
pub static AMQP_STATUS_WRONG_METHOD: ::libc::c_int = -12;
pub static AMQP_STATUS_TIMEOUT: ::libc::c_int = -13;
pub static AMQP_STATUS_TIMER_FAILURE: ::libc::c_int = -14;
pub static AMQP_STATUS_HEARTBEAT_TIMEOUT: ::libc::c_int = -15;
pub static AMQP_STATUS_UNEXPECTED_STATE: ::libc::c_int = -16;
pub static AMQP_STATUS_TCP_ERROR: ::libc::c_int = -256;
pub static AMQP_STATUS_TCP_SOCKETLIB_INIT_ERROR: ::libc::c_int = -257;
pub static AMQP_STATUS_SSL_ERROR: ::libc::c_int = -512;
pub static AMQP_STATUS_SSL_HOSTNAME_VERIFY_FAILED: ::libc::c_int = -513;
pub static AMQP_STATUS_SSL_PEER_VERIFY_FAILED: ::libc::c_int = -514;
pub static AMQP_STATUS_SSL_CONNECTION_FAILED: ::libc::c_int = -515;
pub type amqp_status_enum = Enum_amqp_status_enum_;
#[repr(C)]
pub struct Struct_amqp_connection_start_t_ {
    pub version_major: uint8_t,
    pub version_minor: uint8_t,
    pub server_properties: amqp_table_t,
    pub mechanisms: amqp_bytes_t,
    pub locales: amqp_bytes_t,
}
pub type amqp_connection_start_t = Struct_amqp_connection_start_t_;
#[repr(C)]
pub struct Struct_amqp_connection_start_ok_t_ {
    pub client_properties: amqp_table_t,
    pub mechanism: amqp_bytes_t,
    pub response: amqp_bytes_t,
    pub locale: amqp_bytes_t,
}
pub type amqp_connection_start_ok_t = Struct_amqp_connection_start_ok_t_;
#[repr(C)]
pub struct Struct_amqp_connection_secure_t_ {
    pub challenge: amqp_bytes_t,
}
pub type amqp_connection_secure_t = Struct_amqp_connection_secure_t_;
#[repr(C)]
pub struct Struct_amqp_connection_secure_ok_t_ {
    pub response: amqp_bytes_t,
}
pub type amqp_connection_secure_ok_t = Struct_amqp_connection_secure_ok_t_;
#[repr(C)]
pub struct Struct_amqp_connection_tune_t_ {
    pub channel_max: uint16_t,
    pub frame_max: uint32_t,
    pub heartbeat: uint16_t,
}
pub type amqp_connection_tune_t = Struct_amqp_connection_tune_t_;
#[repr(C)]
pub struct Struct_amqp_connection_tune_ok_t_ {
    pub channel_max: uint16_t,
    pub frame_max: uint32_t,
    pub heartbeat: uint16_t,
}
pub type amqp_connection_tune_ok_t = Struct_amqp_connection_tune_ok_t_;
#[repr(C)]
pub struct Struct_amqp_connection_open_t_ {
    pub virtual_host: amqp_bytes_t,
    pub capabilities: amqp_bytes_t,
    pub insist: amqp_boolean_t,
}
pub type amqp_connection_open_t = Struct_amqp_connection_open_t_;
#[repr(C)]
pub struct Struct_amqp_connection_open_ok_t_ {
    pub known_hosts: amqp_bytes_t,
}
pub type amqp_connection_open_ok_t = Struct_amqp_connection_open_ok_t_;
#[repr(C)]
pub struct Struct_amqp_connection_close_t_ {
    pub reply_code: uint16_t,
    pub reply_text: amqp_bytes_t,
    pub class_id: uint16_t,
    pub method_id: uint16_t,
}
pub type amqp_connection_close_t = Struct_amqp_connection_close_t_;
#[repr(C)]
pub struct Struct_amqp_connection_close_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_connection_close_ok_t = Struct_amqp_connection_close_ok_t_;
#[repr(C)]
pub struct Struct_amqp_channel_open_t_ {
    pub out_of_band: amqp_bytes_t,
}
pub type amqp_channel_open_t = Struct_amqp_channel_open_t_;
#[repr(C)]
pub struct Struct_amqp_channel_open_ok_t_ {
    pub channel_id: amqp_bytes_t,
}
pub type amqp_channel_open_ok_t = Struct_amqp_channel_open_ok_t_;
#[repr(C)]
pub struct Struct_amqp_channel_flow_t_ {
    pub active: amqp_boolean_t,
}
pub type amqp_channel_flow_t = Struct_amqp_channel_flow_t_;
#[repr(C)]
pub struct Struct_amqp_channel_flow_ok_t_ {
    pub active: amqp_boolean_t,
}
pub type amqp_channel_flow_ok_t = Struct_amqp_channel_flow_ok_t_;
#[repr(C)]
pub struct Struct_amqp_channel_close_t_ {
    pub reply_code: uint16_t,
    pub reply_text: amqp_bytes_t,
    pub class_id: uint16_t,
    pub method_id: uint16_t,
}
pub type amqp_channel_close_t = Struct_amqp_channel_close_t_;
#[repr(C)]
pub struct Struct_amqp_channel_close_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_channel_close_ok_t = Struct_amqp_channel_close_ok_t_;
#[repr(C)]
pub struct Struct_amqp_access_request_t_ {
    pub realm: amqp_bytes_t,
    pub exclusive: amqp_boolean_t,
    pub passive: amqp_boolean_t,
    pub active: amqp_boolean_t,
    pub write: amqp_boolean_t,
    pub read: amqp_boolean_t,
}
pub type amqp_access_request_t = Struct_amqp_access_request_t_;
#[repr(C)]
pub struct Struct_amqp_access_request_ok_t_ {
    pub ticket: uint16_t,
}
pub type amqp_access_request_ok_t = Struct_amqp_access_request_ok_t_;
#[repr(C)]
pub struct Struct_amqp_exchange_declare_t_ {
    pub ticket: uint16_t,
    pub exchange: amqp_bytes_t,
    pub _type: amqp_bytes_t,
    pub passive: amqp_boolean_t,
    pub durable: amqp_boolean_t,
    pub auto_delete: amqp_boolean_t,
    pub internal: amqp_boolean_t,
    pub nowait: amqp_boolean_t,
    pub arguments: amqp_table_t,
}
pub type amqp_exchange_declare_t = Struct_amqp_exchange_declare_t_;
#[repr(C)]
pub struct Struct_amqp_exchange_declare_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_exchange_declare_ok_t = Struct_amqp_exchange_declare_ok_t_;
#[repr(C)]
pub struct Struct_amqp_exchange_delete_t_ {
    pub ticket: uint16_t,
    pub exchange: amqp_bytes_t,
    pub if_unused: amqp_boolean_t,
    pub nowait: amqp_boolean_t,
}
pub type amqp_exchange_delete_t = Struct_amqp_exchange_delete_t_;
#[repr(C)]
pub struct Struct_amqp_exchange_delete_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_exchange_delete_ok_t = Struct_amqp_exchange_delete_ok_t_;
#[repr(C)]
pub struct Struct_amqp_exchange_bind_t_ {
    pub ticket: uint16_t,
    pub destination: amqp_bytes_t,
    pub source: amqp_bytes_t,
    pub routing_key: amqp_bytes_t,
    pub nowait: amqp_boolean_t,
    pub arguments: amqp_table_t,
}
pub type amqp_exchange_bind_t = Struct_amqp_exchange_bind_t_;
#[repr(C)]
pub struct Struct_amqp_exchange_bind_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_exchange_bind_ok_t = Struct_amqp_exchange_bind_ok_t_;
#[repr(C)]
pub struct Struct_amqp_exchange_unbind_t_ {
    pub ticket: uint16_t,
    pub destination: amqp_bytes_t,
    pub source: amqp_bytes_t,
    pub routing_key: amqp_bytes_t,
    pub nowait: amqp_boolean_t,
    pub arguments: amqp_table_t,
}
pub type amqp_exchange_unbind_t = Struct_amqp_exchange_unbind_t_;
#[repr(C)]
pub struct Struct_amqp_exchange_unbind_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_exchange_unbind_ok_t = Struct_amqp_exchange_unbind_ok_t_;
#[repr(C)]
pub struct Struct_amqp_queue_declare_t_ {
    pub ticket: uint16_t,
    pub queue: amqp_bytes_t,
    pub passive: amqp_boolean_t,
    pub durable: amqp_boolean_t,
    pub exclusive: amqp_boolean_t,
    pub auto_delete: amqp_boolean_t,
    pub nowait: amqp_boolean_t,
    pub arguments: amqp_table_t,
}
pub type amqp_queue_declare_t = Struct_amqp_queue_declare_t_;
#[repr(C)]
pub struct Struct_amqp_queue_declare_ok_t_ {
    pub queue: amqp_bytes_t,
    pub message_count: uint32_t,
    pub consumer_count: uint32_t,
}
pub type amqp_queue_declare_ok_t = Struct_amqp_queue_declare_ok_t_;
#[repr(C)]
pub struct Struct_amqp_queue_bind_t_ {
    pub ticket: uint16_t,
    pub queue: amqp_bytes_t,
    pub exchange: amqp_bytes_t,
    pub routing_key: amqp_bytes_t,
    pub nowait: amqp_boolean_t,
    pub arguments: amqp_table_t,
}
pub type amqp_queue_bind_t = Struct_amqp_queue_bind_t_;
#[repr(C)]
pub struct Struct_amqp_queue_bind_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_queue_bind_ok_t = Struct_amqp_queue_bind_ok_t_;
#[repr(C)]
pub struct Struct_amqp_queue_purge_t_ {
    pub ticket: uint16_t,
    pub queue: amqp_bytes_t,
    pub nowait: amqp_boolean_t,
}
pub type amqp_queue_purge_t = Struct_amqp_queue_purge_t_;
#[repr(C)]
pub struct Struct_amqp_queue_purge_ok_t_ {
    pub message_count: uint32_t,
}
pub type amqp_queue_purge_ok_t = Struct_amqp_queue_purge_ok_t_;
#[repr(C)]
pub struct Struct_amqp_queue_delete_t_ {
    pub ticket: uint16_t,
    pub queue: amqp_bytes_t,
    pub if_unused: amqp_boolean_t,
    pub if_empty: amqp_boolean_t,
    pub nowait: amqp_boolean_t,
}
pub type amqp_queue_delete_t = Struct_amqp_queue_delete_t_;
#[repr(C)]
pub struct Struct_amqp_queue_delete_ok_t_ {
    pub message_count: uint32_t,
}
pub type amqp_queue_delete_ok_t = Struct_amqp_queue_delete_ok_t_;
#[repr(C)]
pub struct Struct_amqp_queue_unbind_t_ {
    pub ticket: uint16_t,
    pub queue: amqp_bytes_t,
    pub exchange: amqp_bytes_t,
    pub routing_key: amqp_bytes_t,
    pub arguments: amqp_table_t,
}
pub type amqp_queue_unbind_t = Struct_amqp_queue_unbind_t_;
#[repr(C)]
pub struct Struct_amqp_queue_unbind_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_queue_unbind_ok_t = Struct_amqp_queue_unbind_ok_t_;
#[repr(C)]
pub struct Struct_amqp_basic_qos_t_ {
    pub prefetch_size: uint32_t,
    pub prefetch_count: uint16_t,
    pub global: amqp_boolean_t,
}
pub type amqp_basic_qos_t = Struct_amqp_basic_qos_t_;
#[repr(C)]
pub struct Struct_amqp_basic_qos_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_basic_qos_ok_t = Struct_amqp_basic_qos_ok_t_;
#[repr(C)]
pub struct Struct_amqp_basic_consume_t_ {
    pub ticket: uint16_t,
    pub queue: amqp_bytes_t,
    pub consumer_tag: amqp_bytes_t,
    pub no_local: amqp_boolean_t,
    pub no_ack: amqp_boolean_t,
    pub exclusive: amqp_boolean_t,
    pub nowait: amqp_boolean_t,
    pub arguments: amqp_table_t,
}
pub type amqp_basic_consume_t = Struct_amqp_basic_consume_t_;
#[repr(C)]
pub struct Struct_amqp_basic_consume_ok_t_ {
    pub consumer_tag: amqp_bytes_t,
}
pub type amqp_basic_consume_ok_t = Struct_amqp_basic_consume_ok_t_;
#[repr(C)]
pub struct Struct_amqp_basic_cancel_t_ {
    pub consumer_tag: amqp_bytes_t,
    pub nowait: amqp_boolean_t,
}
pub type amqp_basic_cancel_t = Struct_amqp_basic_cancel_t_;
#[repr(C)]
pub struct Struct_amqp_basic_cancel_ok_t_ {
    pub consumer_tag: amqp_bytes_t,
}
pub type amqp_basic_cancel_ok_t = Struct_amqp_basic_cancel_ok_t_;
#[repr(C)]
pub struct Struct_amqp_basic_publish_t_ {
    pub ticket: uint16_t,
    pub exchange: amqp_bytes_t,
    pub routing_key: amqp_bytes_t,
    pub mandatory: amqp_boolean_t,
    pub immediate: amqp_boolean_t,
}
pub type amqp_basic_publish_t = Struct_amqp_basic_publish_t_;
#[repr(C)]
pub struct Struct_amqp_basic_return_t_ {
    pub reply_code: uint16_t,
    pub reply_text: amqp_bytes_t,
    pub exchange: amqp_bytes_t,
    pub routing_key: amqp_bytes_t,
}
pub type amqp_basic_return_t = Struct_amqp_basic_return_t_;
#[repr(C)]
pub struct Struct_amqp_basic_deliver_t_ {
    pub consumer_tag: amqp_bytes_t,
    pub delivery_tag: uint64_t,
    pub redelivered: amqp_boolean_t,
    pub exchange: amqp_bytes_t,
    pub routing_key: amqp_bytes_t,
}
pub type amqp_basic_deliver_t = Struct_amqp_basic_deliver_t_;
#[repr(C)]
pub struct Struct_amqp_basic_get_t_ {
    pub ticket: uint16_t,
    pub queue: amqp_bytes_t,
    pub no_ack: amqp_boolean_t,
}
pub type amqp_basic_get_t = Struct_amqp_basic_get_t_;
#[repr(C)]
pub struct Struct_amqp_basic_get_ok_t_ {
    pub delivery_tag: uint64_t,
    pub redelivered: amqp_boolean_t,
    pub exchange: amqp_bytes_t,
    pub routing_key: amqp_bytes_t,
    pub message_count: uint32_t,
}
pub type amqp_basic_get_ok_t = Struct_amqp_basic_get_ok_t_;
#[repr(C)]
pub struct Struct_amqp_basic_get_empty_t_ {
    pub cluster_id: amqp_bytes_t,
}
pub type amqp_basic_get_empty_t = Struct_amqp_basic_get_empty_t_;
#[repr(C)]
pub struct Struct_amqp_basic_ack_t_ {
    pub delivery_tag: uint64_t,
    pub multiple: amqp_boolean_t,
}
pub type amqp_basic_ack_t = Struct_amqp_basic_ack_t_;
#[repr(C)]
pub struct Struct_amqp_basic_reject_t_ {
    pub delivery_tag: uint64_t,
    pub requeue: amqp_boolean_t,
}
pub type amqp_basic_reject_t = Struct_amqp_basic_reject_t_;
#[repr(C)]
pub struct Struct_amqp_basic_recover_async_t_ {
    pub requeue: amqp_boolean_t,
}
pub type amqp_basic_recover_async_t = Struct_amqp_basic_recover_async_t_;
#[repr(C)]
pub struct Struct_amqp_basic_recover_t_ {
    pub requeue: amqp_boolean_t,
}
pub type amqp_basic_recover_t = Struct_amqp_basic_recover_t_;
#[repr(C)]
pub struct Struct_amqp_basic_recover_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_basic_recover_ok_t = Struct_amqp_basic_recover_ok_t_;
#[repr(C)]
pub struct Struct_amqp_basic_nack_t_ {
    pub delivery_tag: uint64_t,
    pub multiple: amqp_boolean_t,
    pub requeue: amqp_boolean_t,
}
pub type amqp_basic_nack_t = Struct_amqp_basic_nack_t_;
#[repr(C)]
pub struct Struct_amqp_tx_select_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_tx_select_t = Struct_amqp_tx_select_t_;
#[repr(C)]
pub struct Struct_amqp_tx_select_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_tx_select_ok_t = Struct_amqp_tx_select_ok_t_;
#[repr(C)]
pub struct Struct_amqp_tx_commit_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_tx_commit_t = Struct_amqp_tx_commit_t_;
#[repr(C)]
pub struct Struct_amqp_tx_commit_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_tx_commit_ok_t = Struct_amqp_tx_commit_ok_t_;
#[repr(C)]
pub struct Struct_amqp_tx_rollback_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_tx_rollback_t = Struct_amqp_tx_rollback_t_;
#[repr(C)]
pub struct Struct_amqp_tx_rollback_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_tx_rollback_ok_t = Struct_amqp_tx_rollback_ok_t_;
#[repr(C)]
pub struct Struct_amqp_confirm_select_t_ {
    pub nowait: amqp_boolean_t,
}
pub type amqp_confirm_select_t = Struct_amqp_confirm_select_t_;
#[repr(C)]
pub struct Struct_amqp_confirm_select_ok_t_ {
    pub dummy: ::libc::c_char,
}
pub type amqp_confirm_select_ok_t = Struct_amqp_confirm_select_ok_t_;
#[repr(C)]
pub struct Struct_amqp_connection_properties_t_ {
    pub _flags: amqp_flags_t,
    pub dummy: ::libc::c_char,
}
pub type amqp_connection_properties_t = Struct_amqp_connection_properties_t_;
#[repr(C)]
pub struct Struct_amqp_channel_properties_t_ {
    pub _flags: amqp_flags_t,
    pub dummy: ::libc::c_char,
}
pub type amqp_channel_properties_t = Struct_amqp_channel_properties_t_;
#[repr(C)]
pub struct Struct_amqp_access_properties_t_ {
    pub _flags: amqp_flags_t,
    pub dummy: ::libc::c_char,
}
pub type amqp_access_properties_t = Struct_amqp_access_properties_t_;
#[repr(C)]
pub struct Struct_amqp_exchange_properties_t_ {
    pub _flags: amqp_flags_t,
    pub dummy: ::libc::c_char,
}
pub type amqp_exchange_properties_t = Struct_amqp_exchange_properties_t_;
#[repr(C)]
pub struct Struct_amqp_queue_properties_t_ {
    pub _flags: amqp_flags_t,
    pub dummy: ::libc::c_char,
}
pub type amqp_queue_properties_t = Struct_amqp_queue_properties_t_;
#[repr(C)]
pub struct Struct_amqp_basic_properties_t_ {
    pub _flags: amqp_flags_t,
    pub content_type: amqp_bytes_t,
    pub content_encoding: amqp_bytes_t,
    pub headers: amqp_table_t,
    pub delivery_mode: uint8_t,
    pub priority: uint8_t,
    pub correlation_id: amqp_bytes_t,
    pub reply_to: amqp_bytes_t,
    pub expiration: amqp_bytes_t,
    pub message_id: amqp_bytes_t,
    pub timestamp: uint64_t,
    pub _type: amqp_bytes_t,
    pub user_id: amqp_bytes_t,
    pub app_id: amqp_bytes_t,
    pub cluster_id: amqp_bytes_t,
}
pub type amqp_basic_properties_t = Struct_amqp_basic_properties_t_;
#[repr(C)]
pub struct Struct_amqp_tx_properties_t_ {
    pub _flags: amqp_flags_t,
    pub dummy: ::libc::c_char,
}
pub type amqp_tx_properties_t = Struct_amqp_tx_properties_t_;
#[repr(C)]
pub struct Struct_amqp_confirm_properties_t_ {
    pub _flags: amqp_flags_t,
    pub dummy: ::libc::c_char,
}
pub type amqp_confirm_properties_t = Struct_amqp_confirm_properties_t_;
#[repr(C)]
pub struct Struct_amqp_message_t_ {
    pub properties: amqp_basic_properties_t,
    pub body: amqp_bytes_t,
    pub pool: amqp_pool_t,
}
pub type amqp_message_t = Struct_amqp_message_t_;
#[repr(C)]
pub struct Struct_amqp_envelope_t_ {
    pub channel: amqp_channel_t,
    pub consumer_tag: amqp_bytes_t,
    pub delivery_tag: uint64_t,
    pub redelivered: amqp_boolean_t,
    pub exchange: amqp_bytes_t,
    pub routing_key: amqp_bytes_t,
    pub message: amqp_message_t,
}
pub type amqp_envelope_t = Struct_amqp_envelope_t_;
#[repr(C)]
pub struct Struct_amqp_connection_info {
    pub user: *mut ::libc::c_char,
    pub password: *mut ::libc::c_char,
    pub host: *mut ::libc::c_char,
    pub vhost: *mut ::libc::c_char,
    pub port: ::libc::c_int,
    pub ssl: amqp_boolean_t,
}
#[link(name = "rabbitmq")]
extern "C" {
    pub static amqp_empty_bytes: amqp_bytes_t;
    pub static amqp_empty_table: amqp_table_t;
    pub static amqp_empty_array: amqp_array_t;
    pub fn select(__nfds: ::libc::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut Struct_timeval) -> ::libc::c_int;
    pub fn pselect(__nfds: ::libc::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const Struct_timespec,
                   __sigmask: *const __sigset_t) -> ::libc::c_int;
    pub fn gnu_dev_major(__dev: ::libc::c_ulonglong) -> ::libc::c_uint;
    pub fn gnu_dev_minor(__dev: ::libc::c_ulonglong) -> ::libc::c_uint;
    pub fn gnu_dev_makedev(__major: ::libc::c_uint, __minor: ::libc::c_uint)
     -> ::libc::c_ulonglong;
    pub fn readv(__fd: ::libc::c_int, __iovec: *const Struct_iovec,
                 __count: ::libc::c_int) -> ssize_t;
    pub fn writev(__fd: ::libc::c_int, __iovec: *const Struct_iovec,
                  __count: ::libc::c_int) -> ssize_t;
    pub fn preadv(__fd: ::libc::c_int, __iovec: *const Struct_iovec,
                  __count: ::libc::c_int, __offset: __off_t) -> ssize_t;
    pub fn pwritev(__fd: ::libc::c_int, __iovec: *const Struct_iovec,
                   __count: ::libc::c_int, __offset: __off_t) -> ssize_t;
    pub fn amqp_version_number() -> uint32_t;
    pub fn amqp_version() -> *const ::libc::c_char;
    pub fn amqp_constant_name(constantNumber: ::libc::c_int) ->
     *const ::libc::c_char;
    pub fn amqp_constant_is_hard_error(constantNumber: ::libc::c_int) ->
     amqp_boolean_t;
    pub fn amqp_method_name(methodNumber: amqp_method_number_t) ->
     *const ::libc::c_char;
    pub fn amqp_method_has_content(methodNumber: amqp_method_number_t) ->
     amqp_boolean_t;
    pub fn amqp_decode_method(methodNumber: amqp_method_number_t,
                              pool: *mut amqp_pool_t, encoded: amqp_bytes_t,
                              decoded: *mut *mut ::libc::c_void) ->
     ::libc::c_int;
    pub fn amqp_decode_properties(class_id: uint16_t, pool: *mut amqp_pool_t,
                                  encoded: amqp_bytes_t,
                                  decoded: *mut *mut ::libc::c_void) ->
     ::libc::c_int;
    pub fn amqp_encode_method(methodNumber: amqp_method_number_t,
                              decoded: *mut ::libc::c_void,
                              encoded: amqp_bytes_t) -> ::libc::c_int;
    pub fn amqp_encode_properties(class_id: uint16_t,
                                  decoded: *mut ::libc::c_void,
                                  encoded: amqp_bytes_t) -> ::libc::c_int;
    pub fn amqp_channel_open(state: amqp_connection_state_t,
                             channel: amqp_channel_t) ->
     *mut amqp_channel_open_ok_t;
    pub fn amqp_channel_flow(state: amqp_connection_state_t,
                             channel: amqp_channel_t, active: amqp_boolean_t)
     -> *mut amqp_channel_flow_ok_t;
    pub fn amqp_exchange_declare(state: amqp_connection_state_t,
                                 channel: amqp_channel_t,
                                 exchange: amqp_bytes_t, _type: amqp_bytes_t,
                                 passive: amqp_boolean_t,
                                 durable: amqp_boolean_t,
                                 arguments: amqp_table_t) ->
     *mut amqp_exchange_declare_ok_t;
    pub fn amqp_exchange_delete(state: amqp_connection_state_t,
                                channel: amqp_channel_t,
                                exchange: amqp_bytes_t,
                                if_unused: amqp_boolean_t) ->
     *mut amqp_exchange_delete_ok_t;
    pub fn amqp_exchange_bind(state: amqp_connection_state_t,
                              channel: amqp_channel_t,
                              destination: amqp_bytes_t, source: amqp_bytes_t,
                              routing_key: amqp_bytes_t,
                              arguments: amqp_table_t) ->
     *mut amqp_exchange_bind_ok_t;
    pub fn amqp_exchange_unbind(state: amqp_connection_state_t,
                                channel: amqp_channel_t,
                                destination: amqp_bytes_t,
                                source: amqp_bytes_t,
                                routing_key: amqp_bytes_t,
                                arguments: amqp_table_t) ->
     *mut amqp_exchange_unbind_ok_t;
    pub fn amqp_queue_declare(state: amqp_connection_state_t,
                              channel: amqp_channel_t, queue: amqp_bytes_t,
                              passive: amqp_boolean_t,
                              durable: amqp_boolean_t,
                              exclusive: amqp_boolean_t,
                              auto_delete: amqp_boolean_t,
                              arguments: amqp_table_t) ->
     *mut amqp_queue_declare_ok_t;
    pub fn amqp_queue_bind(state: amqp_connection_state_t,
                           channel: amqp_channel_t, queue: amqp_bytes_t,
                           exchange: amqp_bytes_t, routing_key: amqp_bytes_t,
                           arguments: amqp_table_t) ->
     *mut amqp_queue_bind_ok_t;
    pub fn amqp_queue_purge(state: amqp_connection_state_t,
                            channel: amqp_channel_t, queue: amqp_bytes_t) ->
     *mut amqp_queue_purge_ok_t;
    pub fn amqp_queue_delete(state: amqp_connection_state_t,
                             channel: amqp_channel_t, queue: amqp_bytes_t,
                             if_unused: amqp_boolean_t,
                             if_empty: amqp_boolean_t) ->
     *mut amqp_queue_delete_ok_t;
    pub fn amqp_queue_unbind(state: amqp_connection_state_t,
                             channel: amqp_channel_t, queue: amqp_bytes_t,
                             exchange: amqp_bytes_t,
                             routing_key: amqp_bytes_t,
                             arguments: amqp_table_t) ->
     *mut amqp_queue_unbind_ok_t;
    pub fn amqp_basic_qos(state: amqp_connection_state_t,
                          channel: amqp_channel_t, prefetch_size: uint32_t,
                          prefetch_count: uint16_t, global: amqp_boolean_t) ->
     *mut amqp_basic_qos_ok_t;
    pub fn amqp_basic_consume(state: amqp_connection_state_t,
                              channel: amqp_channel_t, queue: amqp_bytes_t,
                              consumer_tag: amqp_bytes_t,
                              no_local: amqp_boolean_t,
                              no_ack: amqp_boolean_t,
                              exclusive: amqp_boolean_t,
                              arguments: amqp_table_t) ->
     *mut amqp_basic_consume_ok_t;
    pub fn amqp_basic_cancel(state: amqp_connection_state_t,
                             channel: amqp_channel_t,
                             consumer_tag: amqp_bytes_t) ->
     *mut amqp_basic_cancel_ok_t;
    pub fn amqp_basic_recover(state: amqp_connection_state_t,
                              channel: amqp_channel_t,
                              requeue: amqp_boolean_t) ->
     *mut amqp_basic_recover_ok_t;
    pub fn amqp_tx_select(state: amqp_connection_state_t,
                          channel: amqp_channel_t) ->
     *mut amqp_tx_select_ok_t;
    pub fn amqp_tx_commit(state: amqp_connection_state_t,
                          channel: amqp_channel_t) ->
     *mut amqp_tx_commit_ok_t;
    pub fn amqp_tx_rollback(state: amqp_connection_state_t,
                            channel: amqp_channel_t) ->
     *mut amqp_tx_rollback_ok_t;
    pub fn amqp_confirm_select(state: amqp_connection_state_t,
                               channel: amqp_channel_t) ->
     *mut amqp_confirm_select_ok_t;
    pub fn init_amqp_pool(pool: *mut amqp_pool_t, pagesize: size_t);
    pub fn recycle_amqp_pool(pool: *mut amqp_pool_t);
    pub fn empty_amqp_pool(pool: *mut amqp_pool_t);
    pub fn amqp_pool_alloc(pool: *mut amqp_pool_t, amount: size_t) ->
     *mut ::libc::c_void;
    pub fn amqp_pool_alloc_bytes(pool: *mut amqp_pool_t, amount: size_t,
                                 output: *mut amqp_bytes_t);
    pub fn amqp_cstring_bytes(cstr: *const ::libc::c_char) -> amqp_bytes_t;
    pub fn amqp_bytes_malloc_dup(src: amqp_bytes_t) -> amqp_bytes_t;
    pub fn amqp_bytes_malloc(amount: size_t) -> amqp_bytes_t;
    pub fn amqp_bytes_free(bytes: amqp_bytes_t);
    pub fn amqp_new_connection() -> amqp_connection_state_t;
    pub fn amqp_get_sockfd(state: amqp_connection_state_t) -> ::libc::c_int;
    pub fn amqp_set_sockfd(state: amqp_connection_state_t,
                           sockfd: ::libc::c_int);
    pub fn amqp_tune_connection(state: amqp_connection_state_t,
                                channel_max: ::libc::c_int,
                                frame_max: ::libc::c_int,
                                heartbeat: ::libc::c_int) -> ::libc::c_int;
    pub fn amqp_get_channel_max(state: amqp_connection_state_t) ->
     ::libc::c_int;
    pub fn amqp_destroy_connection(state: amqp_connection_state_t) ->
     ::libc::c_int;
    pub fn amqp_handle_input(state: amqp_connection_state_t,
                             received_data: amqp_bytes_t,
                             decoded_frame: *mut amqp_frame_t) ->
     ::libc::c_int;
    pub fn amqp_release_buffers_ok(state: amqp_connection_state_t) ->
     amqp_boolean_t;
    pub fn amqp_release_buffers(state: amqp_connection_state_t);
    pub fn amqp_maybe_release_buffers(state: amqp_connection_state_t);
    pub fn amqp_maybe_release_buffers_on_channel(state:
                                                     amqp_connection_state_t,
                                                 channel: amqp_channel_t);
    pub fn amqp_send_frame(state: amqp_connection_state_t,
                           frame: *const amqp_frame_t) -> ::libc::c_int;
    pub fn amqp_table_entry_cmp(entry1: *const ::libc::c_void,
                                entry2: *const ::libc::c_void) ->
     ::libc::c_int;
    pub fn amqp_open_socket(hostname: *const ::libc::c_char,
                            portnumber: ::libc::c_int) -> ::libc::c_int;
    pub fn amqp_send_header(state: amqp_connection_state_t) -> ::libc::c_int;
    pub fn amqp_frames_enqueued(state: amqp_connection_state_t) ->
     amqp_boolean_t;
    pub fn amqp_simple_wait_frame(state: amqp_connection_state_t,
                                  decoded_frame: *mut amqp_frame_t) ->
     ::libc::c_int;
    pub fn amqp_simple_wait_frame_noblock(state: amqp_connection_state_t,
                                          decoded_frame: *mut amqp_frame_t,
                                          tv: *mut Struct_timeval) ->
     ::libc::c_int;
    pub fn amqp_simple_wait_method(state: amqp_connection_state_t,
                                   expected_channel: amqp_channel_t,
                                   expected_method: amqp_method_number_t,
                                   output: *mut amqp_method_t) ->
     ::libc::c_int;
    pub fn amqp_send_method(state: amqp_connection_state_t,
                            channel: amqp_channel_t, id: amqp_method_number_t,
                            decoded: *mut ::libc::c_void) -> ::libc::c_int;
    pub fn amqp_simple_rpc(state: amqp_connection_state_t,
                           channel: amqp_channel_t,
                           request_id: amqp_method_number_t,
                           expected_reply_ids: *mut amqp_method_number_t,
                           decoded_request_method: *mut ::libc::c_void) ->
     amqp_rpc_reply_t;
    pub fn amqp_simple_rpc_decoded(state: amqp_connection_state_t,
                                   channel: amqp_channel_t,
                                   request_id: amqp_method_number_t,
                                   reply_id: amqp_method_number_t,
                                   decoded_request_method:
                                       *mut ::libc::c_void) ->
     *mut ::libc::c_void;
    pub fn amqp_get_rpc_reply(state: amqp_connection_state_t) ->
     amqp_rpc_reply_t;
    pub fn amqp_login(state: amqp_connection_state_t,
                      vhost: *const ::libc::c_char,
                      channel_max: ::libc::c_int, frame_max: ::libc::c_int,
                      heartbeat: ::libc::c_int,
                      sasl_method: amqp_sasl_method_enum, ...) ->
     amqp_rpc_reply_t;
    pub fn amqp_login_with_properties(state: amqp_connection_state_t,
                                      vhost: *const ::libc::c_char,
                                      channel_max: ::libc::c_int,
                                      frame_max: ::libc::c_int,
                                      heartbeat: ::libc::c_int,
                                      properties: *const amqp_table_t,
                                      sasl_method: amqp_sasl_method_enum, ...)
     -> amqp_rpc_reply_t;
    pub fn amqp_basic_publish(state: amqp_connection_state_t,
                              channel: amqp_channel_t, exchange: amqp_bytes_t,
                              routing_key: amqp_bytes_t,
                              mandatory: amqp_boolean_t,
                              immediate: amqp_boolean_t,
                              properties:
                                  *const Struct_amqp_basic_properties_t_,
                              body: amqp_bytes_t) -> ::libc::c_int;
    pub fn amqp_channel_close(state: amqp_connection_state_t,
                              channel: amqp_channel_t, code: ::libc::c_int) ->
     amqp_rpc_reply_t;
    pub fn amqp_connection_close(state: amqp_connection_state_t,
                                 code: ::libc::c_int) -> amqp_rpc_reply_t;
    pub fn amqp_basic_ack(state: amqp_connection_state_t,
                          channel: amqp_channel_t, delivery_tag: uint64_t,
                          multiple: amqp_boolean_t) -> ::libc::c_int;
    pub fn amqp_basic_get(state: amqp_connection_state_t,
                          channel: amqp_channel_t, queue: amqp_bytes_t,
                          no_ack: amqp_boolean_t) -> amqp_rpc_reply_t;
    pub fn amqp_basic_reject(state: amqp_connection_state_t,
                             channel: amqp_channel_t, delivery_tag: uint64_t,
                             requeue: amqp_boolean_t) -> ::libc::c_int;
    pub fn amqp_data_in_buffer(state: amqp_connection_state_t) ->
     amqp_boolean_t;
    pub fn amqp_error_string(err: ::libc::c_int) -> *mut ::libc::c_char;
    pub fn amqp_error_string2(err: ::libc::c_int) -> *const ::libc::c_char;
    pub fn amqp_decode_table(encoded: amqp_bytes_t, pool: *mut amqp_pool_t,
                             output: *mut amqp_table_t, offset: *mut size_t)
     -> ::libc::c_int;
    pub fn amqp_encode_table(encoded: amqp_bytes_t, input: *mut amqp_table_t,
                             offset: *mut size_t) -> ::libc::c_int;
    pub fn amqp_table_clone(original: *mut amqp_table_t,
                            clone: *mut amqp_table_t, pool: *mut amqp_pool_t)
     -> ::libc::c_int;
    pub fn amqp_read_message(state: amqp_connection_state_t,
                             channel: amqp_channel_t,
                             message: *mut amqp_message_t,
                             flags: ::libc::c_int) -> amqp_rpc_reply_t;
    pub fn amqp_destroy_message(message: *mut amqp_message_t);
    pub fn amqp_consume_message(state: amqp_connection_state_t,
                                envelope: *mut amqp_envelope_t,
                                timeout: *mut Struct_timeval,
                                flags: ::libc::c_int) -> amqp_rpc_reply_t;
    pub fn amqp_destroy_envelope(envelope: *mut amqp_envelope_t);
    pub fn amqp_default_connection_info(parsed:
                                            *mut Struct_amqp_connection_info);
    pub fn amqp_parse_url(url: *mut ::libc::c_char,
                          parsed: *mut Struct_amqp_connection_info) ->
     ::libc::c_int;
    pub fn amqp_socket_open(_self: *mut amqp_socket_t,
                            host: *const ::libc::c_char, port: ::libc::c_int)
     -> ::libc::c_int;
    pub fn amqp_socket_open_noblock(_self: *mut amqp_socket_t,
                                    host: *const ::libc::c_char,
                                    port: ::libc::c_int,
                                    timeout: *mut Struct_timeval) ->
     ::libc::c_int;
    pub fn amqp_socket_get_sockfd(_self: *mut amqp_socket_t) -> ::libc::c_int;
    pub fn amqp_get_socket(state: amqp_connection_state_t) ->
     *mut amqp_socket_t;
    pub fn amqp_ssl_socket_new(state: amqp_connection_state_t) ->
     *mut amqp_socket_t;
    pub fn amqp_ssl_socket_set_cacert(_self: *mut amqp_socket_t,
                                      cacert: *const ::libc::c_char) ->
     ::libc::c_int;
    pub fn amqp_ssl_socket_set_key(_self: *mut amqp_socket_t,
                                   cert: *const ::libc::c_char,
                                   key: *const ::libc::c_char) ->
     ::libc::c_int;
    pub fn amqp_ssl_socket_set_key_buffer(_self: *mut amqp_socket_t,
                                          cert: *const ::libc::c_char,
                                          key: *const ::libc::c_void,
                                          n: size_t) -> ::libc::c_int;
    pub fn amqp_ssl_socket_set_verify(_self: *mut amqp_socket_t,
                                      verify: amqp_boolean_t);
    pub fn amqp_set_initialize_ssl_library(do_initialize: amqp_boolean_t);
    pub fn amqp_tcp_socket_new(state: amqp_connection_state_t) ->
     *mut amqp_socket_t;
    pub fn amqp_tcp_socket_set_sockfd(base: *mut amqp_socket_t,
                                      sockfd: ::libc::c_int);
}
